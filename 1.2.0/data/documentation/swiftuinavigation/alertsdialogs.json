{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with new tools for driving alerts and confirmation dialogs from optional and enum"},{"type":"text","text":" "},{"type":"text","text":"state, and makes them more testable."}]},{"anchor":"Alerts","level":3,"type":"heading","text":"Alerts"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose you have a feature for deleting something in your application and you want to show an alert"},{"type":"text","text":" "},{"type":"text","text":"for the user to confirm the deletion. You can do this by holding onto an optional "},{"type":"codeVoice","code":"AlertState"},{"type":"text","text":" in"},{"type":"text","text":" "},{"type":"text","text":"your model, as well as an enum that describes every action that can happen in the alert:"}]},{"type":"codeListing","syntax":"swift","code":["@Observable","class FeatureModel {","  var alert: AlertState<AlertAction>?","  enum AlertAction {","    case deletionConfirmed","  }","","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, when you need to show an alert you can update the alert state with a title, message and"},{"type":"text","text":" "},{"type":"text","text":"buttons:"}]},{"type":"codeListing","syntax":"swift","code":["func deleteButtonTapped() {","  self.alert = AlertState {","    TextState(\"Are you sure?\")","  } actions: {","    ButtonState(\"Delete\", action: .send(.delete))","    ButtonState(\"Nevermind\", role: .cancel)","  } message: {","    TextState(\"Deleting this item cannot be undone.\")","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type "},{"type":"codeVoice","code":"TextState"},{"type":"text","text":" is closely related to "},{"type":"codeVoice","code":"Text"},{"type":"text","text":" from SwiftUI, but plays more nicely with"},{"type":"text","text":" "},{"type":"text","text":"equatability. This makes it possible to write tests against these values."}]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"actions"},{"type":"text","text":" closure is a result builder, which allows you to insert small bits of logic:"}]},{"type":"codeListing","syntax":"swift","code":["} actions: {","  if item.isLocked {","    ButtonState(\"Unlock and delete\", action: .send(.unlockAndDelete))","  } else {","    ButtonState(\"Delete\", action: .send(.delete))","  }","  ButtonState(\"Nevermind\", role: .cancel)","}"]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next you can provide an endpoint that will be called when the alert is interacted with:"}]},{"type":"codeListing","syntax":"swift","code":["func alertButtonTapped(_ action: AlertAction?) {","  switch action {","  case .deletionConfirmed:","    \/\/ NB: Perform deletion logic here","  case nil:","    \/\/ NB: Perform cancel button logic here","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, you can use a new, overloaded "},{"type":"codeVoice","code":".alert"},{"type":"text","text":" view modifier for showing the alert when this state"},{"type":"text","text":" "},{"type":"text","text":"becomes non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","  @ObservedObject var model: FeatureModel","","  var body: some View {","    List {","      \/\/ ...","    }","    .alert(self.$model.alert) { action in","      self.model.alertButtonTapped(action)","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By having all of the alert’s state in your feature’s model, you instantly unlock the ability to test"},{"type":"text","text":" "},{"type":"text","text":"it:"}]},{"type":"codeListing","syntax":"swift","code":["func testDelete() {","  let model = FeatureModel(\/* ... *\/)","","  model.deleteButtonTapped()","  XCTAssertEqual(model.alert?.title, TextState(\"Are you sure?\"))","","  model.alertButtonTapped(.deletionConfirmation)","  \/\/ NB: Assert that deletion actually occurred.","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This works because all of the types for describing an alert are "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", including "},{"type":"codeVoice","code":"AlertState"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"codeVoice","code":"TextState"},{"type":"text","text":", and even the buttons."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sometimes it is not optimal to model the alert as an optional. In particular, if a feature can"},{"type":"text","text":" "},{"type":"text","text":"navigate to multiple, mutually exclusive screens, then a “case-pathable” enum is more appropriate."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In such a case:"}]},{"type":"codeListing","syntax":"swift","code":["@Observable","class FeatureModel {","  var destination: Destination?","","  @CasePathable","  enum Destination {","    case alert(AlertState<AlertAction>)","    \/\/ NB: Other destinations","  }","","  enum AlertAction {","    case deletionConfirmed","  }","","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With this kind of set up you can use an alternative "},{"type":"codeVoice","code":"alert"},{"type":"text","text":" view modifier that takes an additional"},{"type":"text","text":" "},{"type":"text","text":"argument for specifying which case of the enum drives the presentation of the alert:"}]},{"type":"codeListing","syntax":"swift","code":[".alert(self.$model.destination.alert) { action in","  self.model.alertButtonTapped(action)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":"case"},{"type":"text","text":" argument is specified via a concept known as “case paths”, which are like"},{"type":"text","text":" "},{"type":"text","text":"key paths except tuned specifically for enums and cases rather than structs and properties. See"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/WhatIsNavigation"},{"type":"text","text":" for more information."}]},{"anchor":"Confirmation-dialogs","level":3,"type":"heading","text":"Confirmation dialogs"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The APIs for driving confirmation dialogs from optional and enum state look nearly identical to that"},{"type":"text","text":" "},{"type":"text","text":"of alerts."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the model for a delete confirmation could look like this:"}]},{"type":"codeListing","syntax":"swift","code":["@Observable","class FeatureModel {","  var dialog: ConfirmationDialogState<DialogAction>?","  enum DialogAction {","    case deletionConfirmed","  }","","  func deleteButtonTapped() {","    self.dialog = ConfirmationDialogState(","      title: TextState(\"Are you sure?\"),","      titleVisibility: .visible,","      message: TextState(\"Deleting this item cannot be undone.\"),","      buttons: [","        .destructive(TextState(\"Delete\"), action: .send(.delete)),","        .cancel(TextState(\"Nevermind\")),","      ]","    )","  }","","  func dialogButtonTapped(_ action: DialogAction?) {","    switch action {","    case .deletionConfirmed:","      \/\/ NB: Perform deletion logic here","    case nil:","      \/\/ NB: Perform cancel button logic here","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then the view would look like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","  @ObservedObject var model: FeatureModel","","  var body: some View {","    List {","      \/\/ ...","    }","    .confirmationDialog(self.$model.dialog) { action in","      self.dialogButtonTapped(action)","    }","  }","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swiftuinavigation\/alertsdialogs"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/AlertsDialogs","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to present alerts and confirmation dialogs in a concise and testable manner."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Alerts and dialogs","role":"collectionGroup","modules":[{"name":"SwiftUINavigation"}]},"hierarchy":{"paths":[["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation"],["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/WhatIsNavigation"]]},"seeAlsoSections":[{"title":"Tools","identifiers":["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Navigation","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/SheetsPopoversCovers","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Bindings"],"generated":true}],"references":{"doc://SwiftUINavigation/documentation/SwiftUINavigation/WhatIsNavigation":{"role":"collectionGroup","title":"What is navigation?","abstract":[{"type":"text","text":"Learn how one can think of navigation as a domain modeling problem, and how that leads to the"},{"type":"text","text":" "},{"type":"text","text":"creation of concise and testable APIs for navigation."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/WhatIsNavigation","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/whatisnavigation"},"doc://SwiftUINavigation/documentation/SwiftUINavigation":{"role":"collection","title":"SwiftUINavigation","abstract":[{"type":"text","text":"Tools for making SwiftUI navigation simpler, more ergonomic and more precise."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation","kind":"symbol","type":"topic","url":"\/documentation\/swiftuinavigation"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/Navigation":{"role":"collectionGroup","title":"Navigation links and destinations","abstract":[{"type":"text","text":"Learn how to drive navigation in "},{"type":"codeVoice","code":"NavigationView"},{"type":"text","text":" and "},{"type":"codeVoice","code":"NavigationStack"},{"type":"text","text":" in a concise and testable"},{"type":"text","text":" "},{"type":"text","text":"manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Navigation","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/navigation"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/Bindings":{"role":"collectionGroup","title":"Bindings","abstract":[{"type":"text","text":"Learn how to manage certain view state, such as "},{"type":"codeVoice","code":"@FocusState"},{"type":"text","text":" directly in your observable classes."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Bindings","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/bindings"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/SheetsPopoversCovers":{"role":"collectionGroup","title":"Sheets, popovers, and covers","abstract":[{"type":"text","text":"Learn how to present sheets, popovers and covers in a concise and testable manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/SheetsPopoversCovers","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/sheetspopoverscovers"}}}